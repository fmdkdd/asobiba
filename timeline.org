* [2015-09-30 mer.]
:PROPERTIES:
:header-args: :results none
:END:
Trying to come up with a fast equivalent to ~which-func-mode~ under Spacemacs.
The most naive implementation would be to lookup backward for the first heading.

#+BEGIN_SRC elisp
(spacemacs|define-mode-line-segment which-org-headline-segment
  (fmdkdd/org-current-headline)
  :when (eq major-mode 'org-mode))

(add-to-list 'spacemacs|define-mode-line-segment 'which-org-headline-segment t)

(defun fmdkdd/org-current-headline ()
  (save-excursion
    (re-search-backward org-complex-heading-regexp nil t)
    (match-string-no-properties 4)))
#+END_SRC

That does not give you the full current hierarchy (bread crumbs).
Actually, there is an ~org-get-heading~.

#+BEGIN_SRC elisp
(spacemacs|define-mode-line-segment which-org-headline-segment
  (org-get-heading)
  :when (eq major-mode 'org-mode))
#+END_SRC

It even gives us the font-lock properties.

There is also a ~org-get-outline-path~ that gives the rest of the crumbs.

#+BEGIN_SRC elisp
(spacemacs|define-mode-line-segment which-org-headline-segment
  (fmdkdd/org-current-headline)
  :when (eq major-mode 'org-mode))

(defun fmdkdd/org-current-headline ()
  (let ((path (append (org-get-outline-path)
                      (cons (org-get-heading t t) nil))))
    (org-format-outline-path path 40)))
#+END_SRC

Removing the text properties can be achieved by calling
~substring-no-properties~.  Though I rather like the effect as is.

Another, longer (but more proper?) way of removing them is the following:

#+BEGIN_SRC elisp
(defun fmdkdd/org-current-headline ()
  (let* ((path (append (org-get-outline-path)
                      (cons (org-get-heading t t) nil)))
        (formatted (org-format-outline-path path 40)))
    (set-text-properties 0 (length formatted) nil formatted)
    formatted))
#+END_SRC

* [2015-10-01 jeu.]
I would like to be able to use Emacs for collaborative editing.  I have light
requirements:

- over local network would suffice.  I just want to be able to share a buffer
  with someone next to me, each with their own computer.  For pair programming
  or teaching.
- I don’t care much about security: I trust the other person since she is right
  next to me.  When we finish, the computer should not be left in a vulnerable
  state however.
- I prefer to stay with my own Spacemacs config, rather than having to use the
  config of the peer.
- it should be painless to setup, and stable.

This [[http://stackoverflow.com/questions/12546722/using-emacs-server-and-emacsclient-on-other-machines-as-other-users][SO thread]] is a good start.

The scenario is as follows.  Host is where the files to be modified reside.
Host has an Emacs session and buffer on file A.  Client wants to drop in Host
and take control of Emacs from his machine, and edit the same buffer.  He can
also split windows, switch buffers, etc.

** Using tramp and ssh
Client needs ssh access to Host.  Client can browse to file A from his Emacs.

However, Host will not see the changes until Client saves.  This is
insufficient.

** Using ~make-frame-on-display~
Emacs can spawn a frame on another X display.

The requirements:

- Allow X to listen to TCP connections.

  Under Ubuntu, X is spawned by lightdm, so, in =/etc/lightdm/lightdm.conf=
  : xserver-allow-tcp=true

  and restart lightdm.

- After that, allow the Host to access the X server with xhost
  : xhost +host

  In Ubuntu, my LAN machines can be accessed via =host.local=.

  One can also use ~xauth~ here, as described in the SO thread.  Deauthorize the
  Host with ~xhost -host~.

- Finally, the Host can spawn a frame from its Emacs on the client display
  server with
  : make-frame-on-display client.local:0

Now, Client can write in the buffer, and Host can see the changes.  Both can
even edit at the same time.

Seems stable.  There is the issue that if any of the peer starts a modal action
(helm lookup, M-x minibuffer spawn), the other cannot type anymore.  When the
modal action is over, the input will be sent to the frame however.

This is a distinct frame, so Client cannot control the Emacs frame on Host.
Splitting windows should be done on both machines.  Client can browse the Host
files.

Host only has one command to spawn.  But Client needs to restart X before
pairing, because tcplisten seems like a fun backdoor to leave open.

Alas, Client is stuck with the Emacs configuration from Host.  This cannot be
avoided, since there is only one Emacs process.

** Using tmux
As suggested [[http://www.emacswiki.org/emacs/tmux_for_collaborative_editing][there]].  However, I could not make the socket sharing work.

Rather, sharing the same tmux session is simple:

- Host does ~tmux new -s pp~ to create a new session named ‘pp’.
- Client does (connected on Host) ~tmux attach -t pp~ to join the session.

With tmux, Client can connect to Host using ssh, and join a tmux session.  Both
share the same cursor.

Since tmux is terminal-based, Emacs runs in tty mode.  Functionality is the
same, but can be unfamiliar for Host.  Using frames would be possible through
ssh X forwarding, but that would not give us more than the previous solution.

Client has to use Host Emacs config, again.  The setup is also slightly more
involved with Host.

But, sharing through tmux is useful beyond Emacs.  So there is that.  And this
solution should work well over the network (if you can ssh to Host).

There is even a wrapper around tmux called [[https://github.com/zolrath/wemux/][wemux]] which simplifies the setup and
provides relevant options for multiple peers.

** Using floobits
A proprietary web service.  Use a Github account, create a workspace (?) and
share files.  Other users you have authorized can then access the workspace, and
you can see the changes in realtime in your editor if you are viewing the same
file.

Rather nice is that every peer is using his own machine and editor.

However, it goes through the Floobits server, thus it’s pretty slow compared to
the previous solutions.

And there is the requirement of going through a workspace.  It might make sense
for collaborative realtime editing of a project, though I’d rather use Git then.
But it’s cumbersome to setup when playing on a throwaway file.

The nail in the coffin is of course having to go through a third-party.  If the
server software was at least available as open source, I could run a local
instance and that would be a pretty good solution.  Alas, that does not appear
to be the case.

** Using rudel
[[http://rudel.sourceforge.net/][Rudel]] is an Emacs package which share functionality with Floobits.

One Emacs must host a rudel session.  Others can join.  The host does not take
part in collaborative editing.  The host passes editing data from one peer to
another using an open protocol.  Other clients can join.

Users in a session can publish a buffer, and others can subscribe to it.  When
you subscribe to a buffer, Rudel opens a new window with the buffer text
inside.  You can then edit the text with your own cursor, and editor.  Changes
are highlighted with the color of each user (that can be disabled through the
menu option, thankfully).

Rudel is intended to work with menu-bar-mode on, it seems.

I don’t know what data Rudel sends, but from the project website, it seems it
can break the functionality of some modes like EShell.  This behavior can be
troubling.

I’m not sure what exactly is the buffer a client edits: does it have a local
copy?  Does it exist only temporarily?

Speed is alright, but slower than tmux and xhost.

Also, the setup is a bit more involved, and the package is in dire need of
maintenance.
* [2015-10-21 mer.]
** Explanations
In web apps, I find it would be useful to be able to ask why a value is 0, or
NaN.  E.g., why a DOM element has its ‘left’ property to ‘12px’.  I would like
to find the culprit code immediately.  Alas, there are no ‘conditional
breakpoints’ in Firefox or Chrome.

Wait, there are!  You can break on attribute modification by right-clicking a
DOM in the Elements panel in Chrome.  In FF, you can conditionally /stop/ a
breakpoint, but not break conditionally.

Anyway, jumping into the debugger when a value is modified is only one part of
the workflow.  That gives you the place where the value is set, but not how the
right-hand side was computed.  You have to backtrack through the call stack to
get this information.

Instead, if a value contains its history, the explanation is always available.
See [[file:javascript/explanation.js][explanation.js]] for a minimal proof of concept.

** Interactive value inspector in s3c
Trying to add interactive value inspectors into s3c.

*** Rationale
Instead of plain text, the editor should put an HTML element that represents the
full object, like in Firefox or Chrome consoles.  Each property can be
inspected.

- Why do you need that?  The current behavior of displaying serialized objects
  is good enough for small programs.  At least you have all the properties on
  display at once.  With an “interactive” object, you have to click to view
  further properties...

- The current behavior is nice and simple, true.  But for larger objects, it
  is unwieldy.  Also, an interactive value inspector opens the door for
  interactive “explanations” of values: backtrack through the code that created
  some value in order to understand why it’s a NaN, or 0, or ...

- Do you really need explanations?  I mean, in a full application it could be
  nice (provided a good signal-to-noise ratio), but s3c is for simple JavaScript
  code for beginners.  To find out why a value is NaN, just add more //: to
  track the flow.

*** Implementation
CodeMirror provides two functions: ~addWidget~ and ~addLineWidget~.  ~addWidget~
puts an HTML element on a line with absolute positioning.  So I can create HTML
to inspect an object, and put it after the delimiter.  It does not matter if the
element is larger than the line: with a positive z-index, it will appear as if
floating over the text.

To do that, in ~write~, instead of replacing, I can call:

: editor.addWidget({line: l}, p, false, "above")

The last argument is undocumented, but it puts the element /on/ the given line
rather than below (the default).

However, the element is absolutely positioned.  It does not move when the line
does, which breaks the illusion that it gives a view of the value to the left of
the delimiter.

To sync the widget, I would need to listen on changes on the document, and move
all markers that are potentially affected.  It is not sufficient to listen to
the ~change~ event of a line, as when a line is moved as a side-effect of
inserting a new line above, no change event is fired.

The ~addLineWidget~ is quite different, as it inserts the element below the line
and appears to be inset /in/ the text.  The lines it takes are not numbered, and
are skipped by the cursor.  It behaves correctly when inserting new lines.  Bit
of a space hog currently, as it eats vertical space rather than making use of
the usually empty space at the right of the screen.

Hacking the DOM created by CodeMirror sounds like a bad idea, if only for
forward compatibility.

* [2015-12-02 mer.]
** Free monad for interpreters
Reading up on free monads.  Again.  And discussing them with Ronan.

Beyond [[http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern][this blog post]], [[http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern][this SO answer]] is particularly helpful.

On a related note, even setting up a Free monad can be seen as boilerplate.
[[http://okmij.org/ftp/Computation/free-monad.html][Okmij shows]] how to eliminate the noise.

* [2015-12-09 mer.]
** GameBoy Sound player
The sound component of Boyo is a mess.  It sort-of works, but there are weird
artifacts coming out after a while.  And it’s eating at least 20% CPU.  And it
doesn’t even pass blargg’s tests!

I want to start from a clean state, and understand how the damn thing works.
Maybe writing a player for GBS files would be a more appropriate target?  I’m
curious as to what these files store anyway.  Can’t be samples, or they would
directly be in a sound format.  So they must be instructions directly from the
ROM, but probably only the instructions relevant to the audio?

Found a [[http://ocremix.org/info/GBS_Format_Specification][spec]] for GBS files.  At that point, eww does not seem capable of
downloading a sample GBS from Zophar.

Got some GBS.  They are indeed smaller than the ROM file from which they are
extracted.  Pokemon Red ROM is 376K while the GBS is 48K for instance.

Looking at the source for gbsplay, it seems indeed that playing the files means
emulating the CPU and the audio unit.

Maybe what would be nice is if we could compile the output from a GBS into audio
instructions only.  To get an output similar to what MOD file looks like for
trackers.  GBS to MOD converter.

* [2015-12-11 ven.]
** GameBoy Sound player
Will try to go with rust-lang.  Why not make it harder on myself?  At least if I
don’t complete the project, I’ll have learned the basics of a new language.

Someone already did a library for [[https://github.com/emu-rs/spc][reading spc]] in Rust!  This will help.

* [2015-12-12 sam.]
** Learning Rust
The proof of concept code I wrote yesterday worked, but some pieces went over my
head.  Today I went over the [[https://doc.rust-lang.org/stable/book/][Rust book]] to RTFM.

Now, I know how I should use result types to avoid deconstructing with match so
much.  And also how to put my utility functions in a module for better
organization in the long term.
