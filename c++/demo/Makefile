# Greatly inspired by this:
# https://stackoverflow.com/a/30142139
#
# Straightforward Makefile that builds everything into the BUILD_DIR, and
# recompiles only what is needed.

# Configurables
CXX := g++
CFLAGS := -std=c++17 -Wall -Wextra -g -O1
BIN := demo
BUILD_DIR := build

ENABLE_ASSERT := 1
HOT_RELOAD    := 1

ifeq ($(ENABLE_ASSERT), 1)
CFLAGS += -DENABLE_ASSERT
endif

ifeq ($(HOT_RELOAD), 1)
CFLAGS += -DHOT_RELOAD
endif

# Submodule dependencies
INCLUDES := -D_REENTRANT -I/usr/include/SDL2
LIBS := -ldl -pthread -lSDL2 -lSDL2_image

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SRC := main.cc sdl.cc

ifeq ($(HOT_RELOAD), 0)
SRC := $(SRC) game.cc
endif

# Put all objects into the build dir, preserving the SRC hierarchy
OBJ := $(SRC:%.cc=$(BUILD_DIR)/%.o)
# The .d files are generated by CC, used to rebuild objs whenever any dependency
# changes
DEP := $(OBJ:%.o=%.d)

# Default target: the main binary
.PHONY: all
all: $(BUILD_DIR)/$(BIN)

GAME_LIB := $(BUILD_DIR)/libgame.so

ifeq ($(HOT_RELOAD), 1)
all: $(GAME_LIB)
endif

$(GAME_LIB): $(BUILD_DIR)/game.o $(BUILD_DIR)/sdl.o
	$(CXX) $(CFLAGS) -shared -fpic -o $@ $^ $(LIBS)
	@pidof $(BIN) && kill -USR1 `pidof $(BIN)`; true

$(BUILD_DIR)/$(BIN): $(OBJ)
# Create build directories on the way
	@mkdir -p $(@D)
	$(CXX) $^ $(CFLAGS) $(LIBS) -o $@

# Include .d files built by the next rule
-include $(DEP)

$(BUILD_DIR)/%.o: %.cc
	@mkdir -p $(@D)
# -MMD generates the .d dependencies on the go
	$(CXX) $< $(CFLAGS) $(INCLUDES) -MMD -c -o $@

.PHONY: clean
clean:
	rm --force $(BUILD_DIR)/$(BIN) $(OBJ) $(DEP) $(GAME_LIB) $(BUILD_DIR)/game.o
