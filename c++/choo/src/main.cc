#include <glad/glad.h>

#include <GLFW/glfw3.h>

#include "imgui.h"
#include "imgui_impl_glfw.h"
#include "imgui_impl_opengl3.h"

#include <chrono>
#include <cstdio>

#include "config.h"
#include "game.h"
#include "ui.h"
#include "utils.h"
#include "vec.h"
#include "version.h"

// Mini Metro minimalist approach is good, but the RNG and lack of depth are
// not. OpenTTD cargo and city generation is a bit of a letdown, but micro is
// great. Factorio is genius, but what if we just wanted to play with trains?
//
// Cargo in TTD seem to appear out of thin air.  What if we went more for a
// Railroad Tycoon 3 simulation?  Cargo is generated by cities, and already
// transits between them, but at a slow pace.  You add trains to speed up trade
// routes, allowing more cargo to be created.  But cities work like recipes in
// Factorio: there's a clear ratio, you need e.g. 2 copper, 2 iron, 1 water to
// grow 1 pop.  Then pops also want to go to other cities.  Other thing that's
// great in Factorio is: you build everything, so there's a sense of
// accomplishment from going to nothing to covering the map with factories.
// In RT3, industries and cities exist, but you can compliment them, build new
// ones, and make them grow.
// With a slider at map generation, you could chose between no industries at
// all, and many.
// Industries should be dynamic though: construction prices should follow
// raw materials prices, wages should follow helping hands availability?

// TODO: trains pick up goods at start, drop at stop
// TODO: ?cargo sells for money, money buys trains, tracks, gas, cargo,
// overhead? -> bankruptcy is failure condition, multiple goals possible as
// long as you are in the green
// TODO: stations? cargo?
// TODO: picking: hovering on station, cargo generators.. (is cursor in BB?)
// TODO: train state: in station, loading, ...
// TODO: placing track is trivial unless there is interesting terrain
// (mountains? rivers?)

static void glfwErrorCallback(int error, const char *description) {
  fprintf(stderr, "Glfw Error %d: %s\n", error, description);
}

static double gYScrollOffset;

static void glfwScrollCallback(GLFWwindow *window, double xoffset,
                               double yoffset) {
  UNUSED(window);
  UNUSED(xoffset);

  gYScrollOffset = yoffset;
}

int main() {
  glfwSetErrorCallback(glfwErrorCallback);
  if (!glfwInit())
    return 1;

  // GL 3.0 + GLSL 130
  const char *glsl_version = "#version 130";
  glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
  glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);
  glfwWindowHint(GLFW_SAMPLES, 8);

  const char windowTitle[128] = {};
  snprintf(const_cast<char *>(windowTitle), ARRAY_SIZE(windowTitle),
           "CHOO %d.%d", CHOO_VERSION_MAJOR, CHOO_VERSION_MINOR);

  const int windowWidth = 800;
  const int windowHeight = 600;

  GLFWwindow *window =
      glfwCreateWindow(windowWidth, windowHeight, windowTitle, NULL, NULL);
  if (window == NULL)
    return 1;
  glfwMakeContextCurrent(window);
  glfwSwapInterval(1); // Enable vsync

  if (gladLoadGL() == 0) {
    fprintf(stderr, "Failed to initialize OpenGL loader!\n");
    return 1;
  }

  ImGui::CreateContext();

  // Setup Platform/Renderer bindings
  ImGui_ImplGlfw_InitForOpenGL(window, true);
  ImGui_ImplOpenGL3_Init(glsl_version);

  glfwMakeContextCurrent(window);

  Game *game;
  game = (Game *)malloc(sizeof(Game));
  ENSURE(game != nullptr);
  game->init();

  UI *ui;
  ui = (UI *)malloc(sizeof(UI));
  ENSURE(ui != nullptr);
  ui->init(game);

  auto lastLoopTime = std::chrono::high_resolution_clock::now();
  u32 updateClockUs = 0;

  gYScrollOffset = 0;
  glfwSetScrollCallback(window, glfwScrollCallback);

  // Main loop
  while (true) {
    glfwPollEvents();

    ui->updateKeys(window);
    ui->updateMouseButtons(window);
    ui->updateScroll(gYScrollOffset);
    gYScrollOffset = 0;
    {
      double mouseX;
      double mouseY;
      glfwGetCursorPos(window, &mouseX, &mouseY);
      ui->updateMouse(mouseX, mouseY);
    }

    if (ui->wasKeyPressed(GLFW_KEY_ESCAPE))
      glfwSetWindowShouldClose(window, GLFW_TRUE);
    if (glfwWindowShouldClose(window))
      break;

    const bool imguiCaptureMouse = ImGui::GetIO().WantCaptureMouse;
    ui->updateCameraControls(imguiCaptureMouse);

    int displayWidth;
    int displayHeight;
    glfwGetFramebufferSize(window, &displayWidth, &displayHeight);

    ui->updateWindowCamera(displayWidth, displayHeight);
    ui->updateInteraction(imguiCaptureMouse);

    // Update with fixed timestep
    auto loopTime = std::chrono::high_resolution_clock::now();
    std::chrono::duration<float, std::micro> loopDtUs =
        (loopTime - lastLoopTime);
    lastLoopTime = loopTime;
    updateClockUs += static_cast<u32>(loopDtUs.count());

    {
      const u32 timestepUs = 5000;
      while (updateClockUs >= timestepUs) {
        updateClockUs -= timestepUs;
        game->update();
      }
    }

    // Draw
    glViewport(0, 0, displayWidth, displayHeight);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glEnable(GL_BLEND);

    auto clearColor = config::backgroundColor;

    glOrtho(ui->cameraLeft, ui->cameraRight, ui->cameraBottom, ui->cameraTop,
            0.0f, 1.0f);
    glClearColor(clearColor.x, clearColor.y, clearColor.z, 0);
    glClear(GL_COLOR_BUFFER_BIT);

    game->render();
    ui->render();

    // Draw ImGui
    ImGui_ImplOpenGL3_NewFrame();
    ImGui_ImplGlfw_NewFrame();
    ImGui::NewFrame();

    ImGui::Text("Frame time (ms): %f", loopDtUs.count() / 1000.0f);
    ImGui::Text("viewport: %d %d", displayWidth, displayHeight);
    ui->renderImgui();

    ImGui::Render();
    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

    // Swap
    glfwSwapBuffers(window);
  }

  ImGui_ImplOpenGL3_Shutdown();
  ImGui_ImplGlfw_Shutdown();
  ImGui::DestroyContext();

  glfwDestroyWindow(window);
  glfwTerminate();

  return 0;
}
